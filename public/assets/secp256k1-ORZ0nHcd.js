import{p as xt,q as Tt,t as at,u as st,v as F,w as Jt,y as te,z as ee,D as ne,F as qt,G as re,J as oe,K as ie}from"./index-DpAOvXqD.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const St=BigInt(0),Et=BigInt(1);function ut(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function ct(e){const n=e.toString(16);return n.length&1?"0"+n:n}function kt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?St:BigInt("0x"+e)}function dt(e){return kt(st(e))}function jt(e){return at(e),kt(st(Uint8Array.from(e).reverse()))}function It(e,n){return xt(e.toString(16).padStart(n*2,"0"))}function Ut(e,n){return It(e,n).reverse()}function $(e,n,t){let r;if(typeof n=="string")try{r=xt(n)}catch(i){throw new Error(e+" must be hex string or Uint8Array, cause: "+i)}else if(Tt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(e+" of length "+t+" expected, got "+s);return r}const mt=e=>typeof e=="bigint"&&St<=e;function se(e,n,t){return mt(e)&&mt(n)&&mt(t)&&n<=e&&e<t}function ce(e,n,t,r){if(!se(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function fe(e){let n;for(n=0;e>St;e>>=Et,n+=1);return n}const ht=e=>(Et<<BigInt(e))-Et;function ae(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=S=>new Uint8Array(S),s=S=>Uint8Array.of(S);let i=r(e),o=r(e),a=0;const u=()=>{i.fill(1),o.fill(0),a=0},g=(...S)=>t(o,i,...S),c=(S=r(0))=>{o=g(s(0),S),i=g(),S.length!==0&&(o=g(s(1),S),i=g())},E=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let S=0;const _=[];for(;S<n;){i=g();const N=i.slice();_.push(N),S+=i.length}return F(..._)};return(S,_)=>{u(),c(S);let N;for(;!(N=_(E()));)c();return u(),N}}function Nt(e,n,t={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(s,i,o){const a=e[s];if(o&&a===void 0)return;const u=typeof a;if(u!==i||a===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${u}`)}Object.entries(n).forEach(([s,i])=>r(s,i,!1)),Object.entries(t).forEach(([s,i])=>r(s,i,!0))}function At(e){const n=new WeakMap;return(t,...r)=>{const s=n.get(t);if(s!==void 0)return s;const i=e(t,...r);return n.set(t,i),i}}class Mt extends Jt{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,te(n);const r=ee(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?n.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=n.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),ne(i)}update(n){return qt(this),this.iHash.update(n),this}digestInto(n){qt(this),at(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return n=n,n.finished=s,n.destroyed=i,n.blockLen=o,n.outputLen=a,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const $t=(e,n,t)=>new Mt(e,n).update(t).digest();$t.create=(e,n)=>new Mt(e,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const j=BigInt(0),k=BigInt(1),P=BigInt(2),ue=BigInt(3),Ct=BigInt(4),Kt=BigInt(5),Vt=BigInt(8);function C(e,n){const t=e%n;return t>=j?t:n+t}function M(e,n,t){let r=e;for(;n-- >j;)r*=r,r%=t;return r}function _t(e,n){if(e===j)throw new Error("invert: expected non-zero number");if(n<=j)throw new Error("invert: expected positive modulus, got "+n);let t=C(e,n),r=n,s=j,i=k;for(;t!==j;){const a=r/t,u=r%t,g=s-i*a;r=t,t=u,s=i,i=g}if(r!==k)throw new Error("invert: does not exist");return C(s,n)}function Yt(e,n){const t=(e.ORDER+k)/Ct,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function le(e,n){const t=(e.ORDER-Kt)/Vt,r=e.mul(n,P),s=e.pow(r,t),i=e.mul(n,s),o=e.mul(e.mul(i,P),s),a=e.mul(i,e.sub(o,e.ONE));if(!e.eql(e.sqr(a),n))throw new Error("Cannot find square root");return a}function de(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-k,t=0;for(;n%P===j;)n/=P,t++;let r=P;const s=wt(e);for(;Ht(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Yt;let i=s.pow(r,n);const o=(n+k)/P;return function(u,g){if(u.is0(g))return g;if(Ht(u,g)!==1)throw new Error("Cannot find square root");let c=t,E=u.mul(u.ONE,i),x=u.pow(g,n),S=u.pow(g,o);for(;!u.eql(x,u.ONE);){if(u.is0(x))return u.ZERO;let _=1,N=u.sqr(x);for(;!u.eql(N,u.ONE);)if(_++,N=u.sqr(N),_===c)throw new Error("Cannot find square root");const z=k<<BigInt(c-_-1),U=u.pow(E,z);c=_,E=u.sqr(U),x=u.mul(x,E),S=u.mul(S,U)}return S}}function he(e){return e%Ct===ue?Yt:e%Vt===Kt?le:de(e)}const we=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ge(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=we.reduce((r,s)=>(r[s]="function",r),n);return Nt(e,t),e}function me(e,n,t){if(t<j)throw new Error("invalid exponent, negatives unsupported");if(t===j)return e.ONE;if(t===k)return n;let r=e.ONE,s=n;for(;t>j;)t&k&&(r=e.mul(r,s)),s=e.sqr(s),t>>=k;return r}function Dt(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),s=n.reduce((o,a,u)=>e.is0(a)?o:(r[u]=o,e.mul(o,a)),e.ONE),i=e.inv(s);return n.reduceRight((o,a,u)=>e.is0(a)?o:(r[u]=e.mul(o,r[u]),e.mul(o,a)),i),r}function Ht(e,n){const t=(e.ORDER-k)/P,r=e.pow(n,t),s=e.eql(r,e.ONE),i=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function ye(e,n){n!==void 0&&re(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function wt(e,n,t=!1,r={}){if(e<=j)throw new Error("invalid field: expected ORDER > 0, got "+e);let s,i;if(typeof n=="object"&&n!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const c=n;c.BITS&&(s=c.BITS),c.sqrt&&(i=c.sqrt),typeof c.isLE=="boolean"&&(t=c.isLE)}else typeof n=="number"&&(s=n),r.sqrt&&(i=r.sqrt);const{nBitLength:o,nByteLength:a}=ye(e,s);if(a>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let u;const g=Object.freeze({ORDER:e,isLE:t,BITS:o,BYTES:a,MASK:ht(o),ZERO:j,ONE:k,create:c=>C(c,e),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return j<=c&&c<e},is0:c=>c===j,isValidNot0:c=>!g.is0(c)&&g.isValid(c),isOdd:c=>(c&k)===k,neg:c=>C(-c,e),eql:(c,E)=>c===E,sqr:c=>C(c*c,e),add:(c,E)=>C(c+E,e),sub:(c,E)=>C(c-E,e),mul:(c,E)=>C(c*E,e),pow:(c,E)=>me(g,c,E),div:(c,E)=>C(c*_t(E,e),e),sqrN:c=>c*c,addN:(c,E)=>c+E,subN:(c,E)=>c-E,mulN:(c,E)=>c*E,inv:c=>_t(c,e),sqrt:i||(c=>(u||(u=he(e)),u(g,c))),toBytes:c=>t?Ut(c,a):It(c,a),fromBytes:c=>{if(c.length!==a)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+c.length);return t?jt(c):dt(c)},invertBatch:c=>Dt(g,c),cmov:(c,E,x)=>x?E:c});return Object.freeze(g)}function Gt(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Ft(e){const n=Gt(e);return n+Math.ceil(n/2)}function pe(e,n,t=!1){const r=e.length,s=Gt(n),i=Ft(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=t?jt(e):dt(e),a=C(o,n-k)+k;return t?Ut(a,s):It(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const et=BigInt(0),X=BigInt(1);function rt(e,n){const t=n.negate();return e?t:n}function be(e,n,t){const r=o=>o.pz,s=Dt(e.Fp,t.map(r));return t.map((o,a)=>o.toAffine(s[a])).map(e.fromAffine)}function Pt(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function yt(e,n){Pt(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),s=2**e,i=ht(e),o=BigInt(e);return{windows:t,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function Ot(e,n,t){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(e&s),u=e>>o;a>r&&(a-=i,u+=X);const g=n*r,c=g+Math.abs(a)-1,E=a===0,x=a<0,S=n%2!==0;return{nextN:u,offset:c,isZero:E,isNeg:x,isNegF:S,offsetF:g}}function Ee(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function Be(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const pt=new WeakMap,Xt=new WeakMap;function bt(e){return Xt.get(e)||1}function Zt(e){if(e!==et)throw new Error("invalid wNAF")}function ve(e,n){return{constTimeNegate:rt,hasPrecomputes(t){return bt(t)!==1},unsafeLadder(t,r,s=e.ZERO){let i=t;for(;r>et;)r&X&&(s=s.add(i)),i=i.double(),r>>=X;return s},precomputeWindow(t,r){const{windows:s,windowSize:i}=yt(r,n),o=[];let a=t,u=a;for(let g=0;g<s;g++){u=a,o.push(u);for(let c=1;c<i;c++)u=u.add(a),o.push(u);a=u.double()}return o},wNAF(t,r,s){let i=e.ZERO,o=e.BASE;const a=yt(t,n);for(let u=0;u<a.windows;u++){const{nextN:g,offset:c,isZero:E,isNeg:x,isNegF:S,offsetF:_}=Ot(s,u,a);s=g,E?o=o.add(rt(S,r[_])):i=i.add(rt(x,r[c]))}return Zt(s),{p:i,f:o}},wNAFUnsafe(t,r,s,i=e.ZERO){const o=yt(t,n);for(let a=0;a<o.windows&&s!==et;a++){const{nextN:u,offset:g,isZero:c,isNeg:E}=Ot(s,a,o);if(s=u,!c){const x=r[g];i=i.add(E?x.negate():x)}}return Zt(s),i},getPrecomputes(t,r,s){let i=pt.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&(typeof s=="function"&&(i=s(i)),pt.set(r,i))),i},wNAFCached(t,r,s){const i=bt(t);return this.wNAF(i,this.getPrecomputes(i,t,s),r)},wNAFCachedUnsafe(t,r,s,i){const o=bt(t);return o===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),r,i)},setWindowSize(t,r){Pt(r,n),Xt.set(t,r),pt.delete(t)}}}function xe(e,n,t,r){let s=n,i=e.ZERO,o=e.ZERO;for(;t>et||r>et;)t&X&&(i=i.add(s)),r&X&&(o=o.add(s)),s=s.double(),t>>=X,r>>=X;return{p1:i,p2:o}}function Se(e,n,t,r){Ee(t,e),Be(r,n);const s=t.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,a=fe(BigInt(s));let u=1;a>12?u=a-3:a>4?u=a-2:a>0&&(u=2);const g=ht(u),c=new Array(Number(g)+1).fill(o),E=Math.floor((n.BITS-1)/u)*u;let x=o;for(let S=E;S>=0;S-=u){c.fill(o);for(let N=0;N<i;N++){const z=r[N],U=Number(z>>BigInt(S)&g);c[U]=c[U].add(t[N])}let _=o;for(let N=c.length-1,z=o;N>0;N--)z=z.add(c[N]),_=_.add(z);if(x=x.add(_),S!==0)for(let N=0;N<u;N++)x=x.double()}return x}function Rt(e,n){if(n){if(n.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return ge(n),n}else return wt(e)}function Ie(e,n,t={}){if(!n||typeof n!="object")throw new Error(`expected valid ${e} CURVE object`);for(const a of["p","n","h"]){const u=n[a];if(!(typeof u=="bigint"&&u>et))throw new Error(`CURVE.${a} must be positive bigint`)}const r=Rt(n.p,t.Fp),s=Rt(n.n,t.Fn),o=["Gx","Gy","a","b"];for(const a of o)if(!r.isValid(n[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function zt(e){e.lowS!==void 0&&ut("lowS",e.lowS),e.prehash!==void 0&&ut("prehash",e.prehash)}class Ne extends Error{constructor(n=""){super(n)}}const K={Err:Ne,_tlv:{encode:(e,n)=>{const{Err:t}=K;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,s=ct(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?ct(s.length/2|128):"";return ct(e)+i+s+n},decode(e,n){const{Err:t}=K;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const s=n[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const u=s&127;if(!u)throw new t("tlv.decode(long): indefinite length not supported");if(u>4)throw new t("tlv.decode(long): byte length is too big");const g=n.subarray(r,r+u);if(g.length!==u)throw new t("tlv.decode: length bytes not complete");if(g[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const c of g)o=o<<8|c;if(r+=u,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=n.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:n.subarray(r+o)}}},_int:{encode(e){const{Err:n}=K;if(e<ot)throw new n("integer: negative integers are not allowed");let t=ct(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=K;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return dt(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=K,s=$("signature",e),{v:i,l:o}=r.decode(48,s);if(o.length)throw new n("invalid signature: left bytes after parsing");const{v:a,l:u}=r.decode(2,i),{v:g,l:c}=r.decode(2,u);if(c.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(g)}},hexFromSig(e){const{_tlv:n,_int:t}=K,r=n.encode(2,t.encode(e.r)),s=n.encode(2,t.encode(e.s)),i=r+s;return n.encode(48,i)}},ot=BigInt(0),it=BigInt(1),qe=BigInt(2),ft=BigInt(3),Ae=BigInt(4);function _e(e,n,t){function r(s){const i=e.sqr(s),o=e.mul(i,s);return e.add(e.add(o,e.mul(s,n)),t)}return r}function Wt(e,n,t){const{BYTES:r}=e;function s(i){let o;if(typeof i=="bigint")o=i;else{let a=$("private key",i);if(n){if(!n.includes(a.length*2))throw new Error("invalid private key");const u=new Uint8Array(r);u.set(a,u.length-a.length),a=u}try{o=e.fromBytes(a)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof i}`)}}if(t&&(o=e.create(o)),!e.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return s}function He(e,n={}){const{Fp:t,Fn:r}=Ie("weierstrass",e,n),{h:s,n:i}=e;Nt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=n;if(o&&(!t.is0(e.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function a(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function u(H,f,h){const{x:l,y:d}=f.toAffine(),w=t.toBytes(l);if(ut("isCompressed",h),h){a();const p=!t.isOdd(d);return F(Qt(p),w)}else return F(Uint8Array.of(4),w,t.toBytes(d))}function g(H){at(H);const f=t.BYTES,h=f+1,l=2*f+1,d=H.length,w=H[0],p=H.subarray(1);if(d===h&&(w===2||w===3)){const m=t.fromBytes(p);if(!t.isValid(m))throw new Error("bad point: is not on curve, wrong x");const y=x(m);let B;try{B=t.sqrt(y)}catch(q){const v=q instanceof Error?": "+q.message:"";throw new Error("bad point: is not on curve, sqrt error"+v)}a();const b=t.isOdd(B);return(w&1)===1!==b&&(B=t.neg(B)),{x:m,y:B}}else if(d===l&&w===4){const m=t.fromBytes(p.subarray(f*0,f*1)),y=t.fromBytes(p.subarray(f*1,f*2));if(!S(m,y))throw new Error("bad point: is not on curve");return{x:m,y}}else throw new Error(`bad point: got length ${d}, expected compressed=${h} or uncompressed=${l}`)}const c=n.toBytes||u,E=n.fromBytes||g,x=_e(t,e.a,e.b);function S(H,f){const h=t.sqr(f),l=x(H);return t.eql(h,l)}if(!S(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const _=t.mul(t.pow(e.a,ft),Ae),N=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(_,N)))throw new Error("bad curve params: a or b");function z(H,f,h=!1){if(!t.isValid(f)||h&&t.is0(f))throw new Error(`bad point coordinate ${H}`);return f}function U(H){if(!(H instanceof I))throw new Error("ProjectivePoint expected")}const W=At((H,f)=>{const{px:h,py:l,pz:d}=H;if(t.eql(d,t.ONE))return{x:h,y:l};const w=H.is0();f==null&&(f=w?t.ONE:t.inv(d));const p=t.mul(h,f),m=t.mul(l,f),y=t.mul(d,f);if(w)return{x:t.ZERO,y:t.ZERO};if(!t.eql(y,t.ONE))throw new Error("invZ was invalid");return{x:p,y:m}}),Y=At(H=>{if(H.is0()){if(n.allowInfinityPoint&&!t.is0(H.py))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=H.toAffine();if(!t.isValid(f)||!t.isValid(h))throw new Error("bad point: x or y not field elements");if(!S(f,h))throw new Error("bad point: equation left != right");if(!H.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Q(H,f,h,l,d){return h=new I(t.mul(h.px,H),h.py,h.pz),f=rt(l,f),h=rt(d,h),f.add(h)}class I{constructor(f,h,l){this.px=z("x",f),this.py=z("y",h,!0),this.pz=z("z",l),Object.freeze(this)}static fromAffine(f){const{x:h,y:l}=f||{};if(!f||!t.isValid(h)||!t.isValid(l))throw new Error("invalid affine point");if(f instanceof I)throw new Error("projective point not allowed");return t.is0(h)&&t.is0(l)?I.ZERO:new I(h,l,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){return be(I,"pz",f)}static fromBytes(f){return at(f),I.fromHex(f)}static fromHex(f){const h=I.fromAffine(E($("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){const h=Wt(r,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return I.BASE.multiply(h(f))}static msm(f,h){return Se(I,r,f,h)}precompute(f=8,h=!0){return V.setWindowSize(this,f),h||this.multiply(ft),this}_setWindowSize(f){this.precompute(f)}assertValidity(){Y(this)}hasEvenY(){const{y:f}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(f)}equals(f){U(f);const{px:h,py:l,pz:d}=this,{px:w,py:p,pz:m}=f,y=t.eql(t.mul(h,m),t.mul(w,d)),B=t.eql(t.mul(l,m),t.mul(p,d));return y&&B}negate(){return new I(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:h}=e,l=t.mul(h,ft),{px:d,py:w,pz:p}=this;let m=t.ZERO,y=t.ZERO,B=t.ZERO,b=t.mul(d,d),O=t.mul(w,w),q=t.mul(p,p),v=t.mul(d,w);return v=t.add(v,v),B=t.mul(d,p),B=t.add(B,B),m=t.mul(f,B),y=t.mul(l,q),y=t.add(m,y),m=t.sub(O,y),y=t.add(O,y),y=t.mul(m,y),m=t.mul(v,m),B=t.mul(l,B),q=t.mul(f,q),v=t.sub(b,q),v=t.mul(f,v),v=t.add(v,B),B=t.add(b,b),b=t.add(B,b),b=t.add(b,q),b=t.mul(b,v),y=t.add(y,b),q=t.mul(w,p),q=t.add(q,q),b=t.mul(q,v),m=t.sub(m,b),B=t.mul(q,O),B=t.add(B,B),B=t.add(B,B),new I(m,y,B)}add(f){U(f);const{px:h,py:l,pz:d}=this,{px:w,py:p,pz:m}=f;let y=t.ZERO,B=t.ZERO,b=t.ZERO;const O=e.a,q=t.mul(e.b,ft);let v=t.mul(h,w),Z=t.mul(l,p),R=t.mul(d,m),L=t.add(h,l),A=t.add(w,p);L=t.mul(L,A),A=t.add(v,Z),L=t.sub(L,A),A=t.add(h,d);let T=t.add(w,m);return A=t.mul(A,T),T=t.add(v,R),A=t.sub(A,T),T=t.add(l,d),y=t.add(p,m),T=t.mul(T,y),y=t.add(Z,R),T=t.sub(T,y),b=t.mul(O,A),y=t.mul(q,R),b=t.add(y,b),y=t.sub(Z,b),b=t.add(Z,b),B=t.mul(y,b),Z=t.add(v,v),Z=t.add(Z,v),R=t.mul(O,R),A=t.mul(q,A),Z=t.add(Z,R),R=t.sub(v,R),R=t.mul(O,R),A=t.add(A,R),v=t.mul(Z,A),B=t.add(B,v),v=t.mul(T,A),y=t.mul(L,y),y=t.sub(y,v),v=t.mul(L,Z),b=t.mul(T,b),b=t.add(b,v),new I(y,B,b)}subtract(f){return this.add(f.negate())}is0(){return this.equals(I.ZERO)}multiply(f){const{endo:h}=n;if(!r.isValidNot0(f))throw new Error("invalid scalar: out of range");let l,d;const w=p=>V.wNAFCached(this,p,I.normalizeZ);if(h){const{k1neg:p,k1:m,k2neg:y,k2:B}=h.splitScalar(f),{p:b,f:O}=w(m),{p:q,f:v}=w(B);d=O.add(v),l=Q(h.beta,b,q,p,y)}else{const{p,f:m}=w(f);l=p,d=m}return I.normalizeZ([l,d])[0]}multiplyUnsafe(f){const{endo:h}=n,l=this;if(!r.isValid(f))throw new Error("invalid scalar: out of range");if(f===ot||l.is0())return I.ZERO;if(f===it)return l;if(V.hasPrecomputes(this))return this.multiply(f);if(h){const{k1neg:d,k1:w,k2neg:p,k2:m}=h.splitScalar(f),{p1:y,p2:B}=xe(I,l,w,m);return Q(h.beta,y,B,d,p)}else return V.wNAFCachedUnsafe(l,f)}multiplyAndAddUnsafe(f,h,l){const d=this.multiplyUnsafe(h).add(f.multiplyUnsafe(l));return d.is0()?void 0:d}toAffine(f){return W(this,f)}isTorsionFree(){const{isTorsionFree:f}=n;return s===it?!0:f?f(I,this):V.wNAFCachedUnsafe(this,i).is0()}clearCofactor(){const{clearCofactor:f}=n;return s===it?this:f?f(I,this):this.multiplyUnsafe(s)}toBytes(f=!0){return ut("isCompressed",f),this.assertValidity(),c(I,this,f)}toRawBytes(f=!0){return this.toBytes(f)}toHex(f=!0){return st(this.toBytes(f))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}I.BASE=new I(e.Gx,e.Gy,t.ONE),I.ZERO=new I(t.ZERO,t.ONE,t.ZERO),I.Fp=t,I.Fn=r;const D=r.BITS,V=ve(I,n.endo?Math.ceil(D/2):D);return I}function Qt(e){return Uint8Array.of(e?2:3)}function Oe(e,n,t={}){Nt(n,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||oe,s=n.hmac||((l,...d)=>$t(n.hash,l,F(...d))),{Fp:i,Fn:o}=e,{ORDER:a,BITS:u}=o;function g(l){const d=a>>it;return l>d}function c(l){return g(l)?o.neg(l):l}function E(l,d){if(!o.isValidNot0(d))throw new Error(`invalid signature ${l}: out of range 1..CURVE.n`)}class x{constructor(d,w,p){E("r",d),E("s",w),this.r=d,this.s=w,p!=null&&(this.recovery=p),Object.freeze(this)}static fromCompact(d){const w=o.BYTES,p=$("compactSignature",d,w*2);return new x(o.fromBytes(p.subarray(0,w)),o.fromBytes(p.subarray(w,w*2)))}static fromDER(d){const{r:w,s:p}=K.toSig($("DER",d));return new x(w,p)}assertValidity(){}addRecoveryBit(d){return new x(this.r,this.s,d)}recoverPublicKey(d){const w=i.ORDER,{r:p,s:m,recovery:y}=this;if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");if(a*qe<w&&y>1)throw new Error("recovery id is ambiguous for h>1 curve");const b=y===2||y===3?p+a:p;if(!i.isValid(b))throw new Error("recovery id 2 or 3 invalid");const O=i.toBytes(b),q=e.fromHex(F(Qt((y&1)===0),O)),v=o.inv(b),Z=Y($("msgHash",d)),R=o.create(-Z*v),L=o.create(m*v),A=e.BASE.multiplyUnsafe(R).add(q.multiplyUnsafe(L));if(A.is0())throw new Error("point at infinify");return A.assertValidity(),A}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,o.neg(this.s),this.recovery):this}toBytes(d){if(d==="compact")return F(o.toBytes(this.r),o.toBytes(this.s));if(d==="der")return xt(K.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return st(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return st(this.toBytes("compact"))}}const S=Wt(o,t.allowedPrivateKeyLengths,t.wrapPrivateKey),_={isValidPrivateKey(l){try{return S(l),!0}catch{return!1}},normPrivateKeyToScalar:S,randomPrivateKey:()=>{const l=a;return pe(r(Ft(l)),l)},precompute(l=8,d=e.BASE){return d.precompute(l,!1)}};function N(l,d=!0){return e.fromPrivateKey(l).toBytes(d)}function z(l){if(typeof l=="bigint")return!1;if(l instanceof e)return!0;const w=$("key",l).length,p=i.BYTES,m=p+1,y=2*p+1;if(!(t.allowedPrivateKeyLengths||o.BYTES===m))return w===m||w===y}function U(l,d,w=!0){if(z(l)===!0)throw new Error("first arg must be private key");if(z(d)===!1)throw new Error("second arg must be public key");return e.fromHex(d).multiply(S(l)).toBytes(w)}const W=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const d=dt(l),w=l.length*8-u;return w>0?d>>BigInt(w):d},Y=n.bits2int_modN||function(l){return o.create(W(l))},Q=ht(u);function I(l){return ce("num < 2^"+u,l,ot,Q),o.toBytes(l)}function D(l,d,w=V){if(["recovered","canonical"].some(L=>L in w))throw new Error("sign() legacy options not supported");const{hash:p}=n;let{lowS:m,prehash:y,extraEntropy:B}=w;m==null&&(m=!0),l=$("msgHash",l),zt(w),y&&(l=$("prehashed msgHash",p(l)));const b=Y(l),O=S(d),q=[I(O),I(b)];if(B!=null&&B!==!1){const L=B===!0?r(i.BYTES):B;q.push($("extraEntropy",L))}const v=F(...q),Z=b;function R(L){const A=W(L);if(!o.isValidNot0(A))return;const T=o.inv(A),nt=e.BASE.multiply(A).toAffine(),J=o.create(nt.x);if(J===ot)return;const G=o.create(T*o.create(Z+J*O));if(G===ot)return;let gt=(nt.x===J?0:2)|Number(nt.y&it),tt=G;return m&&g(G)&&(tt=c(G),gt^=1),new x(J,tt,gt)}return{seed:v,k2sig:R}}const V={lowS:n.lowS,prehash:!1},H={lowS:n.lowS,prehash:!1};function f(l,d,w=V){const{seed:p,k2sig:m}=D(l,d,w);return ae(n.hash.outputLen,o.BYTES,s)(p,m)}e.BASE.precompute(8);function h(l,d,w,p=H){const m=l;d=$("msgHash",d),w=$("publicKey",w),zt(p);const{lowS:y,prehash:B,format:b}=p;if("strict"in p)throw new Error("options.strict was renamed to lowS");if(b!==void 0&&!["compact","der","js"].includes(b))throw new Error('format must be "compact", "der" or "js"');const O=typeof m=="string"||Tt(m),q=!O&&!b&&typeof m=="object"&&m!==null&&typeof m.r=="bigint"&&typeof m.s=="bigint";if(!O&&!q)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let v,Z;try{if(q)if(b===void 0||b==="js")v=new x(m.r,m.s);else throw new Error("invalid format");if(O){try{b!=="compact"&&(v=x.fromDER(m))}catch(tt){if(!(tt instanceof K.Err))throw tt}!v&&b!=="der"&&(v=x.fromCompact(m))}Z=e.fromHex(w)}catch{return!1}if(!v||y&&v.hasHighS())return!1;B&&(d=n.hash(d));const{r:R,s:L}=v,A=Y(d),T=o.inv(L),nt=o.create(A*T),J=o.create(R*T),G=e.BASE.multiplyUnsafe(nt).add(Z.multiplyUnsafe(J));return G.is0()?!1:o.create(G.x)===R}return Object.freeze({getPublicKey:N,getSharedSecret:U,sign:f,verify:h,utils:_,Point:e,Signature:x})}function Ze(e){const n={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},t=e.Fp,r=wt(n.n,e.nBitLength),s={Fp:t,Fn:r,allowedPrivateKeyLengths:e.allowedPrivateKeyLengths,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,wrapPrivateKey:e.wrapPrivateKey,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:n,curveOpts:s}}function Re(e){const{CURVE:n,curveOpts:t}=Ze(e),r={hash:e.hash,hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:n,curveOpts:t,ecdsaOpts:r}}function ze(e,n){return Object.assign({},n,{ProjectivePoint:n.Point,CURVE:e})}function Le(e){const{CURVE:n,curveOpts:t,ecdsaOpts:r}=Re(e),s=He(n,t),i=Oe(s,r,t);return ze(e,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Te(e,n){const t=r=>Le({...e,hash:r});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const lt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const ke=BigInt(1),Bt=BigInt(2),Lt=(e,n)=>(e+n/Bt)/n;function je(e){const n=lt.p,t=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),u=BigInt(88),g=e*e*e%n,c=g*g*e%n,E=M(c,t,n)*c%n,x=M(E,t,n)*c%n,S=M(x,Bt,n)*g%n,_=M(S,s,n)*S%n,N=M(_,i,n)*_%n,z=M(N,a,n)*N%n,U=M(z,u,n)*z%n,W=M(U,a,n)*N%n,Y=M(W,t,n)*c%n,Q=M(Y,o,n)*_%n,I=M(Q,r,n)*g%n,D=M(I,Bt,n);if(!vt.eql(vt.sqr(D),e))throw new Error("Cannot find square root");return D}const vt=wt(lt.p,void 0,void 0,{sqrt:je}),Me=Te({...lt,Fp:vt,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=lt.n,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ke*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Lt(i*e,n),u=Lt(-r*e,n);let g=C(e-a*t-u*s,n),c=C(-a*r-u*i,n);const E=g>o,x=c>o;if(E&&(g=n-g),x&&(c=n-c),g>o||c>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:E,k1:g,k2neg:x,k2:c}}}},ie);export{Me as secp256k1};
